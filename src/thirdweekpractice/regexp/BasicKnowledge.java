package thirdweekpractice.regexp;

public class BasicKnowledge {
    /*
    1) Текст: Море, море, океан
    regexp: море
    Найдет - "море"

    2) Поиск любово символа
    Regex: А.я
    Текст:
    Аня
    Ася
    Оля
    Аля
    Валя

    . - найдет любой символ (один).
    Точка найдет вообще любой символ, включая цифры, спецсисимволы, даже пробелы.

    Точку точка тоже найдет!
    Regex: file.
    file.txt
    file1.txt
    file2.xls

    Скажем, мы хотим найти все файлы с расширением txt и пишем такой шаблон:
    Regex: .txt
    -> экранирование
    regex: \.txt
    \. - точка (экранирование)

    3) Поиск по набору символов
 Допустим, мы хотим найти имена «Алла», «Анна» в списке. Можно попробовать поиск через точку,
 но кроме нормальных имен, вернется всякая фигня:
    Regex: А..а
    Анна
    Алла
    аоикА74арплт
    Аркан
    А^&а
    Абба
Если же мы хотим именно Анну да Аллу, вместо точки нужно использовать диапазон допустимых значений.
Ставим квадратные скобки, а внутри них перечисляем нужные символы:
Regex: А[нл][нл]а

Пример:
[нл] — только «н» и «л»
[а-я] — все русские буквы в нижнем регистре от «а» до «я» (кроме «ё»)
[А-Я]    — все заглавные русские буквы
[А-Яа-яЁё]  — все русские буквы
[a-z]  — латиница мелким шрифтом
[a-zA-Z]  — все английские буквы
[0-9]  — любая цифра
[В-Ю]   — буквы от «В» до «Ю» (да, диапазон — это не только от А до Я)
[А-ГО-Р]   — буквы от «А» до «Г» и от «О» до «Р»


4) Исключение
^ внутри [] означает исключение:
[^0-9]  — любой символ, кроме цифр
[^ёЁ]  — любой символ, кроме буквы «ё»
[^а-в8]  — любой символ, кроме букв «а», «б», «в» и цифры 8

Regex: fruits\[[0-9]\]
fruits[0] = “апельсин”;
fruits[1] = “яблоко”;
fruits[2] = “лимон”;
Разберем по частям регулярное выражение — fruits\[[0-9]\]
Сначала идет просто текст — «fruits».
Потом обратный слеш. Ага, он что-то экранирует.
Что именно? Квадратную скобку. Значит, это просто квадратная скобка в моем тексте — «fruits[»
Дальше снова квадратная скобка. Она не экранирована — значит, это набор допустимых значений.
Ищем закрывающую квадратную скобку.
Пока получается: fruits[«любое однозназначное число»

5) Перечисление вариантов
Квадратные скобки [] помогают перечислить варианты для одного символа.
Если же мы хотим перечислить слова, то лучше использовать вертикальную черту — |.

Regex: Оля|Олечка|Котик

Regex: А(н|л)я
Найдет:
Аня
Аля

Круглые скобки обозначают группу символов.
В этой группе у нас или буква «н», или буква «л». Зачем нужны скобки?
Показать, где начинается и заканчивается группа.
Иначе вертикальная черта применится ко всем символам — мы будем искать или «Ан», или «ля»:

Пример:
А(н|л)я
А[нл]я
Эти 2 варианта вернут одно и то же
Но для замены одной буквы лучше использовать [],
так как сравнение с символьным классом выполняется проще, чем обработка группы с проверкой на все её
возможные модификаторы

6) Метасимволы
Если мы хотим найти число, то пишем диапазон [0-9].
Если букву, то [а-яА-ЯёЁa-zA-Z].

В регулярных выражениях используются специальные метасимволы,
которые заменяют собой конкретный диапазон значений:
Символ  Эквивалент  Пояснение
   \d   [0-9]       Цифровой символ
   \D   [^0-9]      Нецифровой символ
   \s   [ \f\n\r\t\v]   Пробельный символ
   \S   [^ \f\n\r\t\v] Непробельный символ
   \w   [[:word:]]      Буквенный или цифровой символ или знак подчёркивания
   \W   [^[:word:]]     Любой символ, кроме буквенного или цифрового символа или знака подчёркивания
   А что значит [[:word:]]?
Это один из способов заменить диапазон.
Чтобы запомнить проще было, написали значения на английском, объединив символы в классы.
{ТАБЛИЦА С КЛАССАМИ}


7) Спецсимволы
Большинство символов в регулярном выражении представляют сами себя за исключением специальных символов:
[ ] \ / ^ $ . | ? * + ( ) { }
Эти символы нужны, чтобы обозначить диапазон допустимых значений или границу фразы,
указать количество повторений,
или сделать что-то еще. В разных типах регулярных выражений этот набор различается

8) Квантификаторы (количество повторений)
квантификаторы — так называют специальные символы в регулярных выражениях, которые указывают количество повторений текста.
Символ «+» означает «одно или более повторений»

Какие есть квантификаторы, кроме знака «+»?
? - Ноль или одно
* - Ноль или более
+ - Один или более

Символ * часто используют с точкой — когда нам неважно, какой идет текст до интересующей нас фразы,
мы заменяем его на «.*» — любой символ ноль или более раз.
Но будьте осторожны! Если использовать «.*» повсеместно, можно получить много ложноположительных срабатываний:
Regex: (Хихи)*(Хаха)*
Найдет:
ХихиХаха
ХихиХихиХихи
Хихи
Хаха
ХихиХихиХахаХахаХаха


Если мы хотим применить квантификатор к группе символов или нескольким словам, их нужно взять в скобки.

Квантификаторы применяются к символу или группе в скобках, которые стоят перед ним.
А что, если мне нужно определенное количество повторений?
Чтобы указать конкретное количество повторений, их надо записать внутри фигурных скобок:

{n} - Ровно n раз
{m,n} - От m до n включительно
{m,} - Не менее m
{,n} - Не более n
Не забывайте — квантификатор применяется к последнему символу!
Regex: data{2}
Найдет: dataa
Не найдет: datadata

Или группе символов, если они взяты в круглые скобки:
Regex: (data){2}
Найдет: datadata
Не найдет: dataa

Иногда квантификатор находит не совсем то, что нам нужно.
Regex: <.*>
Ожидание:
<req>
<query>Ан</query>
<gender>FEMALE</gender>
Реальность:
<req> <query>Ан</query> <gender>FEMALE</gender></req>
Мы хотим найти все теги HTML или XML по отдельности, а регулярное выражение возвращает целую строку,
внутри которой есть несколько тегов.

В некоторых реализациях квантификаторам соответствует максимально длинная строка из возможных.
Такие квантификаторы называют жадными.

Если мы понимаем, что нашли не то, что хотели, можно пойти двумя путями:
1) Учитывать символы, не соответствующие желаемому образцу
2) Определить квантификатор как нежадный (ленивый, англ.
Оно ищет открывающий тег, внутри которого все, что угодно, кроме закрывающегося тега «>», и только потом тег закрывается. Так мы не даем захватить
лишнее. Но учтите, использование ленивых квантификаторов может повлечь за собой обратную проблему — когда выражению соответствует слишком короткая, в
частности, пустая строка.

Жадный      Ленивый
   *             *?
   +             +?
  {n,}          {n,}?

9) Позиция внутри строки

Если мы хотим найти конкретную фразу, а не слово, то используем следующие спецсимволы:
^ — начало текста (строки)
$ — конец текста (строки)
Если использовать их, мы будем уверены, что в наш текст не закралось ничего лишнего:
Regex: ^Я нашел!$
Я нашел!
Не найдет:
Смотри! Я нашел!
Я нашел! Посмотри!

10) Замена (replace)
Важная функция регулярных выражений — не только найти текст, но и заменить его на другой текст!
Простейший вариант замены — слово на слово:
RegEx: Ольга
Замена: Макар
Текст был: Привет, Ольга!
Текст стал: Привет, Макар!

Но что, если у нас в исходном тексте может быть любое имя?
Вот что пользователь ввел, то и сохранилось. А нам надо на Макара теперь заменить.
Как сделать такую замену? Через знак доллара. Давайте разберемся с ним подробнее.
Знак доллара в замене — обращение к группе в поиске. Ставим знак доллара и номер группы.
Группа — это то, что мы взяли в круглые скобки. Нумерация у групп начинается с 1.

RegEx: (Оля) \+ Маша
Замена: $1
Текст был: Оля + Маша
Текст стал: Оля

Мы искали фразу «Оля + Маша» (круглые скобки не экранированы, значит, в искомом тексте их быть не должно,
это просто группа). А заменили ее на первую группу — то, что написано в первых круглых скобках, то есть текст «Оля».







     */
}
